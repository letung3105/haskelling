module StateMonad where

import           Data.Char

-- Write functions that manipulate some from of state
-- that can be changed over time.

type State = Int

-- The most basic form of function on this type is a
-- *state transformer*, abbreviated by `ST`, which
-- takes an input state and produces an ouput state
-- along with a result value, with the type being
-- a parameter of the `ST` type.
--
-- ```haskell
-- type ST = State -> State
-- ```
--
-- State transformers may also wish to take argument
-- values, which can be achieved by exploiting
-- currying `Char -> ST Int` is similar to
-- `Char -> State -> (Int, State)`
--
-- ```haskell
-- type ST a = State -> (a, State)
-- ```
--
-- Given that `ST` is a parameterised type, it is
-- natural to try and make it into a monad so that
-- the do notation can then be used to write stateful
-- programs. For that we have to defined `ST` using
-- the `newtype` mechanism
newtype ST a = S (State -> (a, State))


-- It is also convenient to define a special-purpose
-- application function for this type, which simple
-- removes the dummy constructor
app :: ST a -> State -> (a, State)
app (S st) = st


-- It is straightforward to make this type into a
-- functor,
--
-- `fmap` allows use to apply a function
-- to the result value of a state transformer.
--
-- the `let` mechanism of Haskell used in the above
-- definition is similar to the `where` mechanism,
-- except that it allows local definitions to be made
-- at the level of expressions rather than at the
-- level of function definitions
instance Functor ST where
  -- fmap :: (a -> b) -> ST a -> ST b
  fmap g st = S f where f s = let (x, s') = app st s in (g x, s')

-- The type `ST` can now be made into an applicative
-- functor. 
--
-- The function `pure` transform a value into a state
-- transformer that simply returns this value without
-- modifying the state.
--
-- The operator `<*>` applies a state transformer that
-- returns the result of applying the function to the
-- argument.
instance Applicative ST where
    -- pure :: a -> ST a
  pure x = S f where f s = (x, s)

  -- (<*>) :: ST (a -> b) -> ST a -> ST b
  stf <*> stx = S b
   where
    b s =
      let (f, s' ) = app stf s
          (x, s'') = app stx s'
      in  (f x, s'')

-- The monadic instance for ST can now be declared
--
-- `st >>= f` applies the state transformer `st` to an
-- initial state `s`, then applies the function `f` to
-- the resulting value `x` to give a new state
-- transformer `f x`, which is then applied to the new
-- state `s'` to give the final result
--
-- In this manner the bind operator for the state
-- monad integrates the sequencing of state
-- transformers with the processing of their result
-- values.
--
-- **Note:**
-- + Within the definition for `>>=` we
-- produce a new state transformer `f x` whose
-- behavior may depend on the result value of the
-- first argument `x`
-- + Whereas with `<*>` we are restricted to using
-- state transformers that are explicitly supplied as
-- arguments
instance Monad ST where
    -- (>>=) :: ST a -> (a -> ST b) -> ST b
  st >>= f = S b where b s = let (x, s') = app st s in app (f x) s'

data Tree a = Leaf a | Node (Tree a) (Tree a)
    deriving Show


tree :: Tree Char
tree = Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c')


-- Consider the problem of defining a function that
-- relabels each leaf in such a tree with a unique
-- integer.
-- This can be implemented by taking the next unique
-- integer as an additional argument, and return the
-- next unique integer as an additional result

rlabel :: Tree a -> Int -> (Tree Int, Int)
rlabel (Leaf _  ) n = (Leaf n, n + 1)
rlabel (Node l r) n = (Node l' r', n'')
 where
  (l', n' ) = rlabel l n
  (r', n'') = rlabel r n'

rlabelExample = fst (rlabel tree 0)

-- However, the definition for `rlabel` is complicated
-- by the need to explicitly thread an integer state
-- through the computation.
--
-- To obtain a simpler definition, we note that the
-- type `Tree a -> Int -> (Tree Int, Int)` can be
-- rewritten using the type of state transformers by
-- `Tree a -> ST (Tree Int)`, where the state is the
-- next fresh integer.
--
-- The next fresh integer can be generated by defining
-- a state transformer that simple returns the current
-- state as its result, and the next integer as the
-- new state

fresh :: ST Int
fresh = S (\n -> (n, n + 1))

-- Using the fact the `ST` is an applicative functor, we
-- can now define a new version of the relabelling
-- function that is written in applicative style.
-- The new version gives the same result, but its
-- definition is much simpler.
--
-- In the base case, we simply apply the `Leaf`
-- constructor to the next fresh integer.
--
-- In the recursive case, we apply the `Node`
-- to the result of labelling the two subtress.

alabel :: Tree a -> ST (Tree Int)
alabel (Leaf _  ) = Leaf <$> fresh
alabel (Node l r) = Node <$> alabel l <*> alabel r

alabelExample = fst (app (alabel tree) 0)

-- Using the fact that `ST` is a monad, we can define
-- an equivalent monadic version of the relabelling

mlabel :: Tree a -> ST (Tree Int)
mlabel (Leaf _) = do
  n <- fresh
  return (Leaf n)
mlabel (Node l r) = do
  l' <- mlabel l
  r' <- mlabel r
  return (Node l' r')

mlabelExample = fst (app (mlabel tree) 0)


-- Generic functions
--
-- Abstracting out the concept of moands enables us
-- the ability to define generic functions that can
-- be used with any monad. A number of functions are
-- provided in the library `Control.Monad`
--
-- A monadic verions of `map` can be defined
-- as follows. `mapM` has the same type as `map`, accept that
-- the argument function and the function itself now have 
-- have monadic return types.

mapM' :: Monad m => (a -> m b) -> [a] -> m [b]
mapM' f []       = return []
mapM' f (x : xs) = do
  y  <- f x
  ys <- mapM' f xs
  return (y : ys)


-- Consider a function that converts a digit
-- character to its numeric value, provided that
-- the character is indeed a digit

conv :: Char -> Maybe Int
conv c | isDigit c = Just (digitToInt c)
       | otherwise = Nothing


-- Applying `mapM` to the `conv` function, gives a
-- means of converting a string of digits into a
-- corresponding list of numeric values, which
-- succeeds if every character in the string is a
-- digit, and fails otherwise

mapMEX01 = mapM conv "1234" -- Just [1,2,3,]
mapMEX02 = mapM conv "123a" -- Nothing

-- A monadic version of `filter` is defined by
-- generalising its type and definition in a similar
-- manner to `mapM` 

filterM' :: Monad m => (a -> m Bool) -> [a] -> m [a]
filterM' f []       = return []
filterM' f (x : xs) = do
  b  <- f x
  ys <- filterM' f xs
  return (if b then x : ys else ys)

-- This provides a conside means of computing the
-- *powerset* of a list, which is given by all
-- possible ways of including or exluding each
-- element of the list
filterMEX01 = filterM' (const [True, False]) [1, 2, 3]


-- The prelude function `concat :: [[a]] -> [a]` on
-- lists is generalised to an arbitrary monad
-- as follows

join :: Monad m => m (m a) -> m a
join mmx = do
  mx <- mmx
  x  <- mx
  return x

joinEX01 = join [[1, 2], [3, 4], [5, 6]]
joinEX02 = join (Just (Just 1))
joinEX03 = join (Just Nothing)
joinEX04 = join Nothing


-- ## Monad Laws
--
-- Two monadic primitives are required to sastify
-- some equational laws
--
-- ```haskell
-- return x >>= f   = f x
-- mx >>= return    = mx
-- (mx >>= f) >>= g = mx >>= (\x -> (f x >>= g))
-- ```
--
-- The first two equations concern the link between
-- `return` and `>>=`. 
-- + The first equation states that if we `return` a
-- value and then feed this into a monadic function,
-- this should give the same result as simply
-- applying the function to the value.
-- + The second equation states that if we feed the
-- result of a monadic computation into the function
-- `return`, this sould give the same result as
-- simple performing the computation.
-- => `return` is the identity for the `>>=` operator.
-- + The third equation expresses that `>>=` is
-- associative.
--      + We can not simple write `mx >>= (f >>= g)`
--      on the RHS of this equation, as this would
--      not be type correct.
--
--
